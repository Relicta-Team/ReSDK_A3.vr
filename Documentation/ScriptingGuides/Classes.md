# Использование ООП в SQF

Для работы с объектами и классами в проекте требуется подключить заголовочный файл `oop.hpp`. Подключенный файл позволяет использовать основные ключевые слова объектной системы:

| Ключевое слово | Описание |
| ------ | -------- |
| `class(name)` | Определение класса, где `name` - имя класса. |
| `extends(base)` | Унаследовать класс от класса base |
| `endclass` | Ключевое слово, обозначающее конец тела класса. |
| `var(name,value)` | Определение члена (поля, переменной) в классе с именем name и значением `value` |
| `var_[num\|str\|bool\|array\|obj\|vobj\|hashmap\](name)` | Определение поля с именем `name` в классе указанного типа (для num - 0; str - ""; bool - false; array - []; obj - objNull; vobj - nullPtr; hashmap - createHashMap)|
| `var_inlinevalue(name,value)` | Определение члена (поля, переменной) в классе с именем name и значением `value`, вычисленным на этапе компиляции |
| `func(name)` | Определение функции/метода, где `name` - имя метода |
| `getter_func(name,value)` | Определение метода для получения значений, вычисляемых при вызове метода. `name` - имя метода, `value` - любое выражение |
| `getterconst_func(name,value)` | Получение константного значения при вызове метода с именем name, value является выражением, получаемым вне контекста класса (т.е. члены класса внутри такого варианта метода недоступны) |
| `super()` | вызов базовой версии метода в котором он указан |
| `this` | Ключевое слово-ссылка, указывающий на этот объект в вызываемом контексте |
| `objParams()` | Указывается в начале метода, уведомляя компилятор о том, что метод не принимает параметров. |
|  `objParams_\[1..6\]()` | Указывается в начале метода, уведомляя компилятор о том, что метод принимает от 1 до 6 параметров. |
| `new(classname)` | Создание экземпляра класса (объекта) типа `classname` |
| `delete(object)` | Удаление объекта, указанного в `object` |
| `instantiate(name)` | Создание экземпляра класса (объекта) типа name, где name - строковое название класса |
| `isTypeOf(object,type)` | Проверяет, является ли указанный объект `object` наследником класса type |

**!Обратите внимание!**
> Ввиду реализации ключевых слов на основе макросов в значениях `var`-ов, `getter_func` и `getterconst_func` не могут использоваться запятые. Для решения данной проблемы в заголовочном файле `engine.hpp` был добавлен макрос `arg`

# Классы и объекты

Класс и объект - это основные концепции объектно-ориентированного программирования (ООП).

Класс - это шаблон или формальное определение, которое описывает состояние (переменные) и поведение (методы) объектов определенного типа. Класс определяет структуру и поведение объектов, которые будут созданы на его основе. Он служит основой для создания объектов с общими свойствами и функциональностью.

Объект - это конкретный экземпляр класса. Он представляет собой реализацию класса и имеет свое собственное уникальное состояние (значения переменных) и поведение (выполнение методов). Объекты создаются на основе класса и имеют доступ к его свойствам и методам.

Отличия между классом и объектом:

* Класс - это абстракция, описывающая общие свойства и методы объектов определенного типа. Он определяет структуру и поведение, но сам по себе не имеет конкретных значений.
Объект - это конкретный экземпляр класса, имеющий конкретные значения переменных состояния и способность выполнять методы.

* Класс является статической сущностью, которая существует во время компиляции или выполнения программы.
Объект является динамической сущностью, создаваемой во время выполнения программы.

* Из одного класса можно создать несколько объектов с разными значениями переменных состояния. Каждый объект имеет свою собственную копию переменных состояния.
Каждый объект имеет свою собственную копию переменных состояния и может изменять их значения независимо от других объектов того же класса.

* Класс может быть унаследован другими классами, что позволяет создавать иерархию классов и наследовать свойства и методы от родительских классов.
Объект не может быть унаследован, поскольку он является конкретной реализацией класса.

В итоге, класс - это общее определение, а объект - это конкретное воплощение этого определения. Классы предоставляют структуру и функциональность, а объекты представляют конкретные данные и действия, связанные с этой структурой.

Для начала определим простой класс и создадим из него объект.

```sqf
// File: testclass.sqf (определен там же, где лежит oop.hpp)
#include "engine.hpp"
#include "oop.hpp"

class(TestClass)
	//конструкторы вызываются при создании объекта
	func(constructor)
	{
		objParams();
		["created!"] call messageBox;
	};
	//деструкторы вызываются при удалении объекта
	func(destructor)
	{
		objParams();
		["destroyed."] call messageBox;
	};

endclass

// ====================================================================

// File: somescript.sqf 
// (лежит в условной папке randomfolder, которая в той же директории,
// где и oop.hpp; вызывается в какой-то определенный момент...)
#include "..\engine.hpp"
#include "..\oop.hpp"

private _object = new(TestClass);
["on object life..."] call messageBox;
delete(_object);

/* выведет в консоль:
	created!
	on object life...
	destroyed.
*/
```

# Поля (переменные класса)

Для работы с полями существует набор макросов-ключевых слов:
| Ключевое слово | Описание |
| -------------- | -------- |
| `getVar(OBJECT,NAME)` | Получить значение поля `NAME` у объекта `OBJECT` |
| `getSelf(NAME)` | Получить значение поля `NAME` у объекта, который является владельцем вызывающего контекста (тоже самое что и `getVar(this,NAME)`) |
| `setVar(OBJECT,NAME,VALUE)` | Установить полю `NAME` объекта `OBJECT` значение `VALUE` |
| `setSelf(NAME,VALUE)` | Тоже самое что и `setVar(this,NAME,VALUE)` |
| `modVar(OBJECT,NAME,VALUE)` | Изменяет значение поля `NAME` объекта `OBJECT`, подставляя слева от полученного значения `VALUE`. Можно представить как `setVar(OBJECT,NAME,getVar(OBJECT,NAME) VALUE)` |
| `modSelf(OBJECT,NAME,VALUE)` | Тоже что и modVar, только в качестве `OBJECT` подставляет `this` |

**!Обратите внимание!**
> Ввиду реализации ключевых слов на основе макросов в значении не могут использоваться запятые. Для решения данной проблемы в заголовочном файле `engine.hpp` был добавлен макрос `arg`:
>> setVar(_obj,itemList, ["item" arg "knife" arg "bottle"]);

```cpp
class(TestClass)
	//если конструктор или декструктор не определены - они будут добавлены неявно с пустым телом методов.

	var_bool(switcher);
	var_str(someString);
	var(testNumber,4);

	func(constructor)
	{
		objParams();

		modSelf(testNumber, / 2); // тоже самое что: setSelf(testNumber, getSelf(testNumber) / 2);
		setVar(this,someString,"hello!"); //так же можно было написать setSelf(someString,"hello!");
		setSelf(switcher,true);
	};



endclass
```

# Наследование и переопределение
Изначально все классы унаследованы от базового класса `Object`. Чтобы явно унаследовать класс от другого класса, используйте ключевое слово `extends(NAME)`, где NAME - имя родительского класса.

**!Обратите внимание!**
> При наследовании классов все члены (поля и методы наследуются в дочерний класс). Если определить член имя которого есть в одном из родительских классов, он будет *переопределён*

```cpp
class(BasicClass)
	var(name,"Базовый класс");
endclass

class(ChildClass) extends(BasicClass)
	var(name,"Дочерний класс");
endclass

// ==================================

private _obj1 = new(BasicClass);
private _obj2 = new(ChildClass);

["basic name: " + getVar(_obj1,name)] call messageBox; // basic name: Базовый класс
["child name: " + getVar(_obj2,name)] call messageBox; // child name: Дочерний класс

[str isTypeOf(_obj1,ChildClass)] call messageBox; //false
[str isTypeOf(_obj2,BasicClass)] call messageBox; //true

//не забудьте удалить объекты после использования
delete(_obj1);
delete(_obj2);
```

# Методы

Для вызова методов (функций класса) существует набор макросов-ключевых слов:
| Ключевое слово | Описание |
| -------------- | -------- |
| `callFunc(OBJECT,NAME)` | вызывает метод `NAME` у объекта `OBJECT` без передачи параметров |
| `callSelf(NAME)` | Аналогично `callFunc`, но вместо `OBJECT` подставляется `this`: `callFunc(this,NAME)` |
| `callFuncParams(OBJECT,NAME,ARGS)` | вызывает метод `NAME` у объекта `OBJECT` с параметрами `ARGS` |
| `callSelfParams(NAME,ARGS)` | Аналогично `callFuncParams`, но вместо `OBJECT` подставляется `this`: `callFuncParams(this,NAME,ARGS)`

**!Обратите внимание!**
> Ввиду реализации ключевых слов на основе макросов в аргументах не могут использоваться запятые. Для решения данной проблемы в заголовочном файле `engine.hpp` был добавлен макрос `arg`:
>> callSelfParams(reverseArray, [1 arg 3 arg 4 arg 5 arg 6]);

```cpp
class(BasicClass)
	func(printHello)
	{
		objParams();
		["hello basic"] call messageBox;
	};
endclass

class(ChildClass) extends(BasicClass)
	func(printHello)
	{
		objParams();
		["hello child"] call messageBox;
	};
endclass

// ========================================
private _obj1 = new(BasicClass);
private _obj2 = new(ChildClass);

callFunc(_obj1,printHello); //hello basic
callFunc(_obj2,printHello); //hello child

//не забудьте удалить объекты после использования
delete(_obj1);
delete(_obj2);

```

## Ключевое слово super()
Но что было бы, если нам резко понадобился бы код из базового класса BasicClass? Переписывать его каждый раз не вариант, ведь с увеличением иерархии наследования и количества классов, количество кода возрасло бы в разы. 

Тут на помощь нам приходит ключевое слово `super()`:

```cpp
class(BasicClass)
	func(printHello)
	{
		objParams();
		// представим, что здесь выполняется много кода, 
		// который нам нужно использовать в дочерних классах, 
		// унаследованных от BasicClass
		["hello basic"] call messageBox;
	};
endclass

class(ChildClass) extends(BasicClass)
	func(printHello)
	{
		objParams();
		//ключевое слово super() вызывает базовую версию метода, определенную в базовом классе
		super();
		["hello child"] call messageBox;
	};
endclass

// ========================================
private _obj = new(ChildClass);

callFunc(_obj,printHello); 
//Выведет последовательно 2 сообщения:
// hello basic
// hello child

delete(_obj);
```

## Параметры методов

До сих пор мы работали исключительно с методами без параметров. Давайте рассмотрим пример, в котором будут использоваться методы с параметрами.

```cpp
class(Human)
	var(name,"");
	var(money,0);
	
	func(constructor)
	{
		objParams();
		setSelf(name, ctxParams ); //ctxParams - ещё одна переменная 
		// для получения параметров, указанных при создании (т.е. используется
		// ТОЛЬКО внутри конструктора
		// Определена в oop.hpp
	};
	
	getter_func(getName,getSelf(name));

	func(addMoneyFrom)
	{
		objParams_2(_src,_amount); //Обратите внимание, что параметры указываются внутри тела
		// метода. Так же внимательно смотрите на количество параметров. Если например вы напишете
		// objParams_5(_src,_amount), то данный пример не скомпилируется и будет вызывана ошибка

		//если _src нулевая ссылка (isNullReference определён в engine.hpp)
		// (например указывает на удаленный объект, 
		// то выходим из области видимости - т.е. из тела метода)
		if isNullReference(_src) exitWith {};

		//если после вычитания из денег _src у него остается 
		// меньше 0, то мы не можем забрать их
		if (getVar(_src,money) - _amount < 0) exitWith {}; 

		//забираем у _src _amount денег
		modVar(_src,money, - _amount);
		//даём this _amount денег
		modSelf(money, + _amount);
	};

	getter_func(getInfo,format["%1 with %2 money" arg callSelf(getName) arg getSelf(money)]);

endclass

// =============================================================

private _a = newParams(Human,"Jonh");
private _b = newParams(Human,"Jack");
setVar(_a,money,20);

[callFunc(_a,getInfo)] call messageBox; //Jonh with 20 money
[callFunc(_b,getInfo)] call messageBox; //Jonh with 0 money

callFuncParams(_b,addMoneyFrom,_a arg 17);

[callFunc(_a,getInfo)] call messageBox; //Jonh with 3 money
[callFunc(_b,getInfo)] call messageBox; //Jonh with 17 money

delete(_a);
delete(_b);
```

#[Следующий раздел](Preprocessor.md)